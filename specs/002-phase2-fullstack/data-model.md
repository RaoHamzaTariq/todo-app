# Data Model: Phase 2 Full-Stack Todo Application

**Date**: 2026-01-04
**Phase**: 1 (Design & Contracts)
**Plan Reference**: [plan.md](./plan.md)
**Research Reference**: [research.md](./research.md)

## Overview

This document defines the data entities, relationships, validation rules, and state transitions for the Phase 2 full-stack todo application. All models align with the database schema defined in `specs/database/schema.md`.

---

## Entities

### User

**Managed by**: Better Auth (frontend authentication library)

**Description**: Represents an authenticated user account in the system. The users table is created and managed by Better Auth's database schema.

**Attributes**:

| Attribute | Type | Constraints | Description |
|-----------|------|-------------|-------------|
| id | string | PRIMARY KEY | Unique user identifier (generated by Better Auth) |
| email | string | UNIQUE, NOT NULL, email format | User's email address for authentication |
| name | string | NULLABLE | User's display name (optional) |
| image | string | NULLABLE, URL format | Avatar URL (optional) |
| password_hash | string | NOT NULL | Hashed password (managed by Better Auth) |
| email_verified | boolean | DEFAULT false | Email verification status |
| created_at | timestamp | NOT NULL | Account creation timestamp |
| updated_at | timestamp | NOT NULL | Last modification timestamp |

**Validation Rules**:
- Email must be valid format (RFC 5322)
- Password must be minimum 8 characters (enforced by Better Auth)
- Name limited to 100 characters (if provided)

**Relationships**:
- User has many Tasks (1:N)

**Note**: Backend does NOT directly modify the users table. Better Auth handles all user management operations (signup, signin, password reset).

---

### Task

**Managed by**: Backend (FastAPI + SQLModel)

**Description**: Represents a todo item owned by a specific user. Tasks support full CRUD operations with strict ownership enforcement.

**Attributes**:

| Attribute | Type | Constraints | Description |
|-----------|------|-------------|-------------|
| id | integer | PRIMARY KEY, AUTO_INCREMENT | Unique task identifier |
| user_id | string | NOT NULL, FOREIGN KEY -> users.id, INDEXED | Owner of the task (immutable after creation) |
| title | string | NOT NULL, 1-200 characters | Task title (required) |
| description | text | NULLABLE, max 1000 characters | Optional task description |
| completed | boolean | NOT NULL, DEFAULT false | Completion status |
| created_at | timestamp | NOT NULL, AUTO_SET | Creation timestamp (immutable) |
| updated_at | timestamp | NOT NULL, AUTO_UPDATE | Last modification timestamp |

**Validation Rules**:

| Rule | Validation | Error Message |
|------|------------|---------------|
| Title required | title != null AND length(title) > 0 | "Title is required" |
| Title length | length(title) <= 200 | "Title must be 200 characters or less" |
| Description length | description == null OR length(description) <= 1000 | "Description must be 1000 characters or less" |
| user_id required | user_id != null | "User ID is required" |
| user_id immutable | On update: user_id == existing_user_id | "Cannot change task owner" |

**Relationships**:
- Task belongs to User (N:1)
  - Foreign key: task.user_id -> user.id
  - Cascade: ON DELETE CASCADE (deleting user deletes their tasks)

**Indexes** (for query performance per SC-003):
- `idx_tasks_user_id` on (user_id) - Filter tasks by owner
- `idx_tasks_completed` on (completed) - Filter by status
- `idx_tasks_user_completed` on (user_id, completed) - Combined filter
- `idx_tasks_created_at` on (created_at) - Sort by creation
- `idx_tasks_title` on (title) - Sort/search by title

---

## State Transitions

### Task Completion Status

```
┌─────────────┐              ┌─────────────┐
│             │              │             │
│  Incomplete │──────────────►   Complete  │
│             │   PATCH      │             │
│             │   /complete  │             │
│             │◄──────────────             │
└─────────────┘              └─────────────┘
      │                            │
      │                            │
      │       DELETE /{id}         │
      └─────────►╳◄────────────────┘
                 (Deleted)
```

**States**:
- **Incomplete** (completed = false): Initial state when task is created
- **Complete** (completed = true): User marked task as done
- **Deleted**: Task removed from database (permanent)

**Allowed Transitions**:

| From State | To State | Trigger | HTTP Method | Endpoint |
|------------|----------|---------|-------------|----------|
| Incomplete | Complete | User marks done | PATCH | /api/{user_id}/tasks/{id}/complete |
| Complete | Incomplete | User marks undone | PATCH | /api/{user_id}/tasks/{id}/complete |
| Incomplete | Deleted | User deletes | DELETE | /api/{user_id}/tasks/{id} |
| Complete | Deleted | User deletes | DELETE | /api/{user_id}/tasks/{id} |

**Invariants**:
- Task completion status can toggle between true/false any number of times
- Once deleted, task cannot be recovered (no soft delete in Phase 2)
- All transitions require authenticated user ownership verification

---

## Database Schema (SQLModel Implementation)

### User Model Reference

```python
# backend/src/app/models/user.py
# Note: This is a reference only. Better Auth manages the users table.

from sqlmodel import SQLModel, Field
from typing import Optional
from datetime import datetime

class User(SQLModel, table=True):
    """
    User model reference (managed by Better Auth).
    Do not create, update, or delete users through backend.
    """
    __tablename__ = "users"

    id: str = Field(primary_key=True)
    email: str = Field(unique=True, nullable=False)
    name: Optional[str] = None
    image: Optional[str] = None
    password_hash: str = Field(nullable=False)
    email_verified: bool = Field(default=False)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
```

### Task Model

```python
# backend/src/app/models/task.py
from sqlmodel import SQLModel, Field, Index
from datetime import datetime
from typing import Optional

class Task(SQLModel, table=True):
    """
    Task model for todo items.

    Relationships:
    - Belongs to User (user_id foreign key)

    Validation:
    - title: required, 1-200 characters
    - description: optional, max 1000 characters
    - user_id: required, immutable after creation
    """
    __tablename__ = "tasks"
    __table_args__ = (
        Index("idx_tasks_user_id", "user_id"),
        Index("idx_tasks_completed", "completed"),
        Index("idx_tasks_user_completed", "user_id", "completed"),
        Index("idx_tasks_created_at", "created_at"),
        Index("idx_tasks_title", "title"),
    )

    id: Optional[int] = Field(default=None, primary_key=True)
    user_id: str = Field(
        foreign_key="users.id",
        nullable=False,
        index=True,
        description="Owner of the task (immutable)"
    )
    title: str = Field(
        min_length=1,
        max_length=200,
        nullable=False,
        description="Task title (required)"
    )
    description: Optional[str] = Field(
        default=None,
        max_length=1000,
        description="Optional task description"
    )
    completed: bool = Field(
        default=False,
        nullable=False,
        description="Completion status"
    )
    created_at: datetime = Field(
        default_factory=datetime.utcnow,
        nullable=False,
        description="Creation timestamp (immutable)"
    )
    updated_at: datetime = Field(
        default_factory=datetime.utcnow,
        nullable=False,
        description="Last modification timestamp"
    )
```

---

## Pydantic Schemas (Request/Response)

### Task Request Schemas

```python
# backend/src/app/schemas/task.py
from pydantic import BaseModel, Field, validator
from typing import Optional

class CreateTaskInput(BaseModel):
    """Schema for creating a new task"""
    title: str = Field(min_length=1, max_length=200, description="Task title")
    description: Optional[str] = Field(None, max_length=1000, description="Task description")

    @validator("title")
    def title_not_empty(cls, v):
        if not v or not v.strip():
            raise ValueError("Title cannot be empty or whitespace")
        return v.strip()


class UpdateTaskInput(BaseModel):
    """Schema for updating an existing task"""
    title: Optional[str] = Field(None, min_length=1, max_length=200)
    description: Optional[str] = Field(None, max_length=1000)
    completed: Optional[bool] = None

    @validator("title")
    def title_not_empty(cls, v):
        if v is not None and (not v or not v.strip()):
            raise ValueError("Title cannot be empty or whitespace")
        return v.strip() if v else v
```

### Task Response Schemas

```python
# backend/src/app/schemas/task.py
from pydantic import BaseModel
from datetime import datetime
from typing import Optional

class TaskResponse(BaseModel):
    """Schema for task API responses"""
    id: int
    user_id: str
    title: str
    description: Optional[str]
    completed: bool
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True  # Enable ORM mode for SQLModel compatibility


class TaskListResponse(BaseModel):
    """Schema for list tasks endpoint response"""
    tasks: list[TaskResponse]
```

### Error Response Schemas

```python
# backend/src/app/schemas/error.py
from pydantic import BaseModel

class ErrorResponse(BaseModel):
    """Standard error response format"""
    detail: str  # Human-readable error message

class ValidationErrorResponse(BaseModel):
    """Validation error response format"""
    detail: str
    errors: list[dict]  # Field-specific validation errors
```

---

## Frontend TypeScript Types

```typescript
// frontend/src/types/task.ts

export interface Task {
  id: number;
  user_id: string;
  title: string;
  description: string | null;
  completed: boolean;
  created_at: string; // ISO 8601 datetime string
  updated_at: string; // ISO 8601 datetime string
}

export interface CreateTaskInput {
  title: string;
  description?: string;
}

export interface UpdateTaskInput {
  title?: string;
  description?: string;
  completed?: boolean;
}

export interface TaskListResponse {
  tasks: Task[];
}

export interface ApiError {
  detail: string;
}
```

---

## Query Patterns

### Common Queries (with Index Usage)

**Q1: Get all tasks for a user**
```sql
SELECT * FROM tasks
WHERE user_id = ? AND completed = ?
ORDER BY created_at DESC;
-- Uses: idx_tasks_user_completed
```

**Q2: Get specific task with ownership check**
```sql
SELECT * FROM tasks
WHERE id = ? AND user_id = ?;
-- Uses: PRIMARY KEY + idx_tasks_user_id
```

**Q3: Count completed vs incomplete tasks**
```sql
SELECT completed, COUNT(*) FROM tasks
WHERE user_id = ?
GROUP BY completed;
-- Uses: idx_tasks_user_completed
```

**Q4: Search tasks by title**
```sql
SELECT * FROM tasks
WHERE user_id = ? AND title ILIKE ?
ORDER BY created_at DESC;
-- Uses: idx_tasks_user_id + idx_tasks_title
```

---

## Data Ownership Rules

Based on Constitution Principle VI (Multi-User Security Law):

### Rule 1: user_id from JWT Token Only

```python
# ✅ CORRECT: user_id from decoded JWT
@router.post("/{user_id}/tasks")
async def create_task(
    user_id: str,
    task_data: CreateTaskInput,
    auth_user: dict = Depends(jwt_bearer),
):
    # Use user_id from JWT token, NOT from path parameter
    new_task = Task(
        user_id=auth_user["user_id"],  # From JWT
        title=task_data.title,
        description=task_data.description,
    )

# ❌ INCORRECT: user_id from request body
new_task = Task(
    user_id=task_data.user_id,  # SECURITY VULNERABILITY!
    ...
)
```

### Rule 2: Ownership Verification on All Operations

```python
# All CRUD operations must verify ownership
def verify_task_ownership(task: Task, auth_user_id: str):
    """Verify task belongs to authenticated user"""
    if task.user_id != auth_user_id:
        raise HTTPException(
            status_code=403,
            detail="Cannot access other user's tasks"
        )
```

### Rule 3: No Cross-User Data Leakage

- GET requests return only tasks where `task.user_id == auth_user["user_id"]`
- UPDATE/DELETE return 404 (not 403) to prevent information disclosure
- Error messages never reveal task existence for other users

---

## Summary

**Entities**: 2 (User, Task)
**Relationships**: 1 (User has many Tasks)
**Indexes**: 5 (optimized for common query patterns)
**Validation Rules**: 5 (title required, length limits, ownership)
**State Transitions**: 3 (Incomplete ↔ Complete, Any → Deleted)

**Alignment**:
- ✅ Spec FR-003 through FR-007 (task CRUD operations)
- ✅ Spec FR-011 (PostgreSQL persistence)
- ✅ Constitution VI (Multi-User Security Law)
- ✅ Constitution IX (Persistence Law - no in-memory)

**Next**: Generate API contracts (OpenAPI specification)
